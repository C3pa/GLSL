Name

    EXT_vulkan_glsl_relaxed

Name Strings

    GL_EXT_vulkan_glsl_relaxed

Contact

    Malcolm Bechard (malcolm 'at' derivative.ca), Derivative

Contributors

    William Brown, Derivative
    Malcolm Bechard, Derivative

Notice

    Copyright (c) 2020 The Khronos Group Inc. Copyright terms at
        http://www.khronos.org/registry/speccopyright.html

Status

Version

Number

    TBD.

Dependencies

    This extension requires GL_KHR_vulkan_glsl.
    
    This extension can be applied to OpenGL GLSL versions 1.40
    (#version 140) and higher.

    This extension can be applied to OpenGL ES ESSL versions 3.10
    (#version 310) and higher.

    All these versions map GLSL/ESSL semantics to the same SPIR-V 1.0
    semantics (approximating the most recent versions of GLSL/ESSL).

Overview

    This extension is built upon the new language features added by
    GL_KHR_vulkan_glsl, but relaxes some of it's changes and restrictions
    to allow for compiling existing OpenGL GLSL and ESSL legal shaders
    without requiring any edits for Vulkan compliance.

    The following previously removed features are re-added:
        * default uniforms (uniform variables not inside a uniform block).
        * shared and packed block layouts, but they are silently ignored.
        * gl_VertexID and gl_InstanceID
        * atomic-counters (those based on atomic_uint)
             
    New features:
        * The type of backing used for a block, push constant or uniform
          buffer, and the layout of the block, can be changed at compile
          time by the user of the GLSL front-end.
        * The set which a uniform belongs to can be changed at compile time
          by the user of the GLSL front-end.
          
Unresolved:
    The previous feature changes are re-changed:
        * the default origin remains origin_lower_left (is this possible with Vulan SPIRV-V?)

    Each of these is discussed in more detail below.

    Enabling These Features
    -----------------------

    This extension is not enabled with a #extension as other extensions are.
    It is also not enabled through use of a profile or #version.  The intended
    level of GLSL/ESSL features, independent from Vulkan-specific usage, comes
    from the traditional use of #version, profile, and #extension.

    Instead, use of this extension is an effect of using a GLSL front-end in a
    mode that has it generate SPIR-V for Vulkan.  Such tool use is outside the
    scope of using the Vulkan API and outside the definition of GLSL and this
    extension. See the documentation of the compiler to see how to request
    generation of SPIR-V for Vulkan using these rules.

    When a front-end is used to accept this extension, it must error check and
    reject shaders not adhering to this specification, and accept those that
    do. Implementation-dependent maximums and capabilities are supplied to, or
    part of, the front-end, so it can do error checking against them.
             
    Default Uniforms
    ---------------
    
    All default uniforms will be silently grouped into a single anonymous
    uniform block. The type name of the block, the backing, set, and binding
    location can all be controlled via options to the GLSL front-end.  

    Shared and Packed Block Layouts
    -------------------------------
    
    If a block is declared with shared or packed layouts, those layouts will
    be ignored and instead the default layout for that block type will be used.
    
    gl_VertexID and gl_InstanceID
    -----------------------------

    Built-in variables gl_VertexID and gl_InstanceID are accepted, but are
    simply aliases to gl_VertexIndex and gl_InstanceIndex which were introduced
    in GL_EXT_vulkan_glsl. They will include the base offset like the
    GL_EXT_vulkan_glsl behavior.
    
    Atomic Integers
    ---------------
    
    atomic_uint declarations will be silently functions inteacting with them
    will be silently converted to use SSBOs and related atomic functions.
   
Changes to Chapter 3 of the OpenGL Shading Language Specification

    Move the following keywords in section 3.6 Keywords back out of
    reserved section:

        atomic_uint

Changes to Chapter 4 of the OpenGL Shading Language Specification

    Re-add the entry from the table in section 4.1 Basic Types:

        atomic_uint

    Re-add the section 4.1.7.3 Atomic Counters

*******************
    Change section 4.4.1, under "Fragment Shader Inputs" back to

      "By default, gl_FragCoord assumes a lower-left origin for window
      coordinates ... For example, the (x, y) location (0.5, 0.5) is
      returned for the lowerleft-most pixel in a window. The origin can be
      changed by redeclaring gl_FragCoord with the
      origin_upper_left identifier."

    To

      "The gl_FragCoord built-in variable assumes an upper-left origin for
      window coordinates ... For example, the (x, y) location (0.5, 0.5) is
      returned for the upper-left-most pixel in a window. The origin can be
      explicitly set by redeclaring gl_FragCoord with the origin_upper_left
      identifier.  It is a compile-time error to change it to
      origin_lower_left."
**********************
    Remove all mention of the 'shared' and 'packed' layout qualifiers.
    
    Add a new paragaph stating:
      "shared and packed layout qualifiers will be accepted but ignored.
      The layout of the block will instead be the default layout for that
      block type".

Changes to Chapter 7 of the OpenGL Shading Language Specification

    Changes to section 7.1 Built-In Language Variables

      Specify for non-ES with:

        "in int gl_VertexID;"
        "in int gl_InstanceID;"
        are aliases for:
        
        "in int gl_VertexIndex;"
        "in int gl_InstanceIndex;"

      For ES, add:

        "in highp int gl_VertexID;"
        "in highp int gl_InstanceID;"
        are aliases for:
        
        "in highp int gl_VertexIndex;"
        "in highp int gl_InstanceIndex;"

Changes to Chapter 8 of the OpenGL Shading Language Specification

    Add the following ES language to desktop versions of the specification:

      "The operation of a built-in function can have a different precision
      qualification than the precision qualification of the resulting value.
      These two precision qualifications are established as follows.

      "The precision qualification of the operation of a built-in function is
      based on the precision qualification of its input arguments and formal
      parameters:  When a formal parameter specifies a precision qualifier,
      that is used, otherwise, the precision qualification of the calling
      argument is used.  The highest precision of these will be the precision
      qualification of the operation of the built-in function. Generally,
      this is applied across all arguments to a built-in function, with the
      exceptions being:
        - bitfieldExtract and bitfieldInsert ignore the 'offset' and 'bits'
          arguments.
        - interpolateAt* functions only look at the 'interpolant' argument.

      "The precision qualification of the result of a built-in function is
      determined in one of the following ways:

        - For the texture sampling, image load, and image store functions,
          the precision of the return type matches the precision of the
          sampler type:
             uniform lowp sampler2D sampler;
             highp vec2 coord;
             ...
             lowp vec4 col = texture (sampler, coord); // texture() returns lowp

        Otherwise:

        - For prototypes that do not specify a resulting precision qualifier,
          the precision will be the same as the precision of the operation.
          (As defined earlier.)

        - For prototypes that do specify a resulting precision qualifier,
          the specified precision qualifier is the precision qualification of
          the result."

    Add precision qualifiers to the following in desktop versions:

      genIType floatBitsToInt (highp genFType value)
      genUType floatBitsToUint(highp genFType value)
      genFType intBitsToFloat (highp genIType value)
      genFType uintBitsToFloat(highp genUType value)

      genFType frexp(highp genFType x, out highp genIType exp)
      genFType ldexp(highp genFType x,  in highp genIType exp)

      highp uint packSnorm2x16(vec2 v)
      vec2 unpackSnorm2x16(highp uint p)
      highp uint packUnorm2x16(vec2 v)
      vec2 unpackUnorm2x16(highp uint p)
      vec2 unpackHalf2x16(highp uint v)
      vec4 unpackUnorm4x8(highp uint v)
      vec4 unpackSnorm4x8(highp uint v)

      genIType bitfieldReverse(highp genIType value)
      genUType bitfieldReverse(highp genUType value)
      genIType findMSB(highp genIType value)
      genIType findMSB(highp genUType value)
      genUType uaddCarry(highp genUType x, highp genUType y,
                         out lowp genUType carry)
      genUType usubBorrow(highp genUType x, highp genUType y,
                          out lowp genUType borrow)
      void umulExtended(highp genUType x, highp genUType y,
                        out highp genUType msb, out highp genUType lsb)
      void imulExtended(highp genIType x, highp genIType y,
                        out highp genIType msb, out highp genIType lsb)

    Remove section 8.10 Atomic-Counter Functions

    Remove section 8.14 Noise Functions

    Remove the entry from the table in section 8.17 Shader Memory Control
    Functions:

        void memoryBarrierAtomicCounter()

    Add a section

      "8.X Subpass Functions

      "Subpass functions are only available in a fragment shader.

      "Subpass inputs are read through the built-in functions below. The gvec...
      and gsubpass... are matched, where they must both be the same floating
      point, integer, or unsigned integer variants.

    Add a table with these two entries (in the same cell):

      "gvec4 subpassLoad(gsubpassInput   subpass)
       gvec4 subpassLoad(gsubpassInputMS subpass, int sample)"

    With the description:

      "Read from a subpass input, from the implicit location (x, y, layer)
      of the current fragment coordinate."

Changes to the grammar

    Arrays can no longer require the size to be a compile-time folded constant
    expression.  Change

      | LEFT_BRACKET constant_expression RIGHT_BRACKET

    to

      | LEFT_BRACKET conditional_expression RIGHT_BRACKET

    and change

      | array_specifier LEFT_BRACKET constant_expression RIGHT_BRACKET

    to

      | array_specifier LEFT_BRACKET conditional_expression RIGHT_BRACKET

    Remove the ATOMIC_UINT type_specifier_nonarray.

    Remove all instances of the SUBROUTINE keyword.

Issues

1. Can we have specialization sizes in an array in a block?  That prevents
   putting known offsets on subsequent members.

   RESOLUTION: Yes, but it does not affect offsets.

2. Can a specialization-sized array be passed by value?

   RESOLUTION: Yes, if they are sized with the same specialization constant.

3. Can a texture array be variably indexed?  Dynamically uniform?

   Resolution (bug 14683): Dynamically uniform indexing.

4. Are arrays of a descriptor set all under the same set number, or does, say,
   an array of size 4 use up 4 descriptor sets?

   RESOLUTION: There is no array of descriptor sets.  Arrays of resources
   are in a single descriptor set and consume a single binding number.

5. Which descriptor set arrays can be variably or non-uniformly indexed?

   RESOLUTION: There is no array of descriptor sets.

6. Do we want an alternate way of doing composite member specialization
   constants?  For example,

       layout(constant_id = 18) gl_WorkGroupSize.y;

   Or

       layout(constant_id = 18, local_size_y = 16) in;

   Or

       layout(constant_id = 18) wgy = 16;
       const ivec3 gl_WorkGroupSize = ivec3(1, wgy, 1);

    RESOLUTION: No. Use local_size_x_id etc. for workgroup size, and
    defer any more generalized way of doing this for composites.

7. What names do we really want to use for
        gl_VertexIndex             base, base+1, base+2, ...
        gl_InstanceIndex           base, base+1, base+2, ...

     RESOLUTION: Use the names above.

     Note that gl_VertexIndex is equivalent to OpenGL's gl_VertexID in that
     it includes the value of the baseVertex parameter. gl_InstanceIndex is
     NOT equivalent to OpenGL's gl_InstanceID because gl_InstanceID does NOT
     include the baseInstance parameter.

8. What should "input subpasses" really be called?

   RESOLVED: subpassInput.

9. The spec currently does not restrict where sampler constructors can go,
   but should it?  E.g., can the user write a shader like the following:

     uniform texture2D t[MAX_TEXTURES];
     uniform sampler s[2];

     uniform int textureCount;
     uniform int sampleCount;
     uniform bool samplerCond;

     float ShadowLookup(bool pcf, vec2 tcBase[MAX_TEXTURES])
     {
         float result = 0;

         for (int textureIndex = 0; textureIndex < textureCount; ++textureIndex)
         {
             for (int sampleIndex = 0; sampleIndex < sampleCount; ++sampleIndex)
             {
                 vec2 tc = tcBase[textureIndex] + offsets[sampleIndex];
                 if (samplerCond)
                     result += texture(sampler2D(t[textureIndex], s[0]), tc).r;
                 else
                     result += texture(sampler2D(t[textureIndex], s[1]), tc).r;
             }

   Or, like this?

     uniform texture2D t[MAX_TEXTURES];
     uniform sampler s[2];

     uniform int textureCount;
     uniform int sampleCount;
     uniform bool samplerCond;

     sampler2D combined0[MAX_TEXTURES] = sampler2D(t, s[0]);
     sampler2D combined1[MAX_TEXTURES] = sampler2D(t, s[1]);

     float ShadowLookup(bool pcf, vec2 tcBase[MAX_TEXTURES])
     {
         for (int textureIndex = 0; textureIndex < textureCount; ++textureIndex) {
             for (int sampleIndex = 0; sampleIndex < sampleCount; ++sampleIndex) {
                 vec2 tc = tcBase[textureIndex] + offsets[sampleIndex];
                 if (samplerCond)
                     result += texture(combined0[textureIndex], tc).r;
                 else
                     result += texture(combined1[textureIndex], tc).r;
             }
         ...

    RESOLUTION (bug 14683): Only constructed at the point of use, where passed
    as an argument to a function parameter.

Revision History


